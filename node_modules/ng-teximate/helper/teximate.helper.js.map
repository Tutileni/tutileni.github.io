{"version":3,"sources":["../inlined/helper/teximate.helper.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAEjD,MAAM,KAAQ,MAAM,CA0EnB;AA1ED,WAAc,MAAM;IAElB,oBAAoB;IACP,cAAO,GAAG,UAAC,KAAK;QAC3B,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;QAC3B,OAAO,CAAC,EAAE,CAAC;YACT,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;YACpC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACb,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACpB,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QACf,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC,CAAC;IAEF;;;OAGG;IACU,kBAAW,GAAG,UAAC,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,aAAa;QAExD,oEAAoE;QAEpE,IAAI,KAAK,CAAC;QACV,IAAI,KAAK,CAAC;QAEV,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC1B,KAAK,aAAa,CAAC,IAAI;gBACrB,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,CAAC;YACR,KAAK,aAAa,CAAC,OAAO;gBACxB,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC3B,KAAK,GAAG,CAAC,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC9E,KAAK,CAAC;YACR;gBACE,WAAW;gBACX,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,GAAG,CAAC,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC9E,CAAC;QACD,MAAM,CAAC;YACL,OAAO,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,OAAO;YAC3B,KAAK,EAAE,KAAK;SACb,CAAC;IACJ,CAAC,CAAC;IAEF;;;OAGG;IACU,oBAAa,GAAG,UAAC,OAAO,EAAE,GAAG,EAAE,CAAC;QAE3C,IAAI,KAAK,CAAC;QACV,IAAI,KAAK,CAAC;QAEV,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5B,KAAK,aAAa,CAAC,IAAI;gBACrB,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,CAAC;YACR,KAAK,aAAa,CAAC,OAAO;gBACxB,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC3B,KAAK,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;gBACjC,KAAK,CAAC;YACR;gBACE,WAAW;gBACX,KAAK,GAAG,CAAC,CAAC;gBACV,KAAK,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;QACrC,CAAC;QAED,MAAM,CAAC;YACL,IAAI,EAAE,GAAG,CAAC,KAAK,CAAC;YAChB,KAAK,EAAE,KAAK;SACb,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,EA1Ea,MAAM,KAAN,MAAM,QA0EnB;AAGD;;;;;;;;;;;;;GAaG","file":"teximate.helper.js","sourceRoot":"","sourcesContent":["import { TeximateOrder } from './teximate.class';\n\nexport module Helper {\n\n  /** Shuffle Array */\n  export const shuffle = (array) => {\n    let m = array.length, t, i;\n    while (m) {\n      i = Math.floor(Math.random() * m--);\n      t = array[m];\n      array[m] = array[i];\n      array[i] = t;\n    }\n    return array;\n  };\n\n  /**\n   * Process a word, returns words letters' array and the delay used to display \n   * such as { ['a', 'b', 'c'], 3500 }\n   */\n  export const processWord = (options, arr, i, relativeIndex) => {\n\n    // relativeIndex: is the word index relative to the letters sequence\n\n    let index;\n    let delay;\n\n    switch (options.word.type) {\n      case TeximateOrder.SYNC:\n        index = i;\n        delay = 0;\n        break;\n      case TeximateOrder.REVERSE:\n        index = arr.length - i - 1;\n        delay = (relativeIndex * options.letter.delay) + (index * options.word.delay);\n        break;\n      default:\n        // SEQUENCE\n        index = i;\n        delay = (relativeIndex * options.letter.delay) + (i * options.word.delay);\n    }\n    return {\n      letters: arr[index].letters,\n      delay: delay\n    };\n  };\n\n  /** \n   * Process a letter, returns the letter content and the delay used to display\n   * such as { 'a', 1500 }\n   */\n  export const processLetter = (options, arr, i) => {\n\n    let index;\n    let delay;\n\n    switch (options.letter.type) {\n      case TeximateOrder.SYNC:\n        index = i;\n        delay = 0;\n        break;\n      case TeximateOrder.REVERSE:\n        index = arr.length - i - 1;\n        delay = i * options.letter.delay;\n        break;\n      default:\n        // SEQUENCE\n        index = i;\n        delay = i * options.letter.delay;\n    }\n\n    return {\n      item: arr[index],\n      delay: delay\n    };\n  };\n}\n\n\n/**\n *\n *\n return Observable.from(textArr)\n .mergeMap((line: any, i) => Observable.of(line.words).delay(i * this.lineInterval))\n .mergeAll()\n .mergeMap((word: any, i) => Observable.of(word.letters).delay(i * this.wordInterval))\n .mergeAll()\n .mergeMap((letter: any, i) => Observable.of(letter).delay(i * this.letterInterval))\n .do((item: Letter) => {\n        item.visibility = 'visible';\n        this.array.next(textArr);\n      })\n */\n"]}