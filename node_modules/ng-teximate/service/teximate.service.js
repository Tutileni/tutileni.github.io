import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/mergeAll';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/delay';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeWhile';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/of';
import { Helper } from '../helper/teximate.helper';
import { TeximateOrder } from '../helper/teximate.class';
/** This service is not meant to be used outside TeximateModule
 *  Each component instance has service instance
 */
var TeximateService = (function () {
    function TeximateService() {
        var _this = this;
        /** The processed text */
        this.arr = [];
        /** A worker to do the job async */
        this.worker = new Subject();
        /** A state used to update the template */
        this.text = new Subject();
        this.worker
            .takeWhile(function () { return !_this.text.closed; })
            .switchMap(function (job) {
            // console.log('worker execute:', job.type);
            return (job.options.type === 'letter') ?
                _this.lettersJob(job.options) :
                _this.wordsJob(job.options);
        })
            .catch(function (res) {
            console.log('[Teximate]:', res);
            return Observable.of(null);
        })
            .subscribe();
    }
    /** Run effect on a new text */
    TeximateService.prototype.createEffect = function (text, options, hover) {
        // Get a processed text to work with
        this.arr = this.textFactory(text, options, hover);
        // Send the job to the worker
        this.worker.next({ options: options, hover: hover });
    };
    /** Run effect on an existing text */
    TeximateService.prototype.runEffect = function (options) {
        this.worker.next({ options: options });
    };
    /** The magic that runs the effect on letters */
    TeximateService.prototype.lettersJob = function (options) {
        var _this = this;
        return Observable.from(this.arr)
            .mergeMap(function (line) {
            // A temp variable used to calculate word's index relative to letters sequence
            var relativeIndex = 0;
            // Shuffle words if shuffle is ordered
            var lineWords = (options.word.type === TeximateOrder.SHUFFLE) ? Helper.shuffle(line.words.slice(0)) : line.words;
            return Observable.of(lineWords)
                .mergeAll()
                .mergeMap(function (wordItem, j) {
                // Process word (calculate index & delay according to word's type)
                var word = Helper.processWord(options, lineWords, j, relativeIndex);
                // Set the index for the next word relative to letter sequence
                relativeIndex += word.letters.length;
                // Shuffle letters if letter type is shuffle
                var wordLetters;
                if (options.letter.type === TeximateOrder.SHUFFLE) {
                    wordLetters = Helper.shuffle(word.letters.slice());
                }
                else {
                    wordLetters = word.letters;
                }
                return Observable.of(wordLetters).delay(word.delay)
                    .mergeAll()
                    .mergeMap(function (letterInstance, k) {
                    /** Process letter (calculate index & delay according to requested order) */
                    var letter = Helper.processLetter(options, wordLetters, k);
                    return Observable.of(letter.item).delay(letter.delay)
                        .do(function (letterItem) { return _this.updateItem(letterItem, options); });
                });
            });
        });
    };
    /** The magic that runs the effect on words */
    TeximateService.prototype.wordsJob = function (options) {
        var _this = this;
        return Observable.from(this.arr)
            .mergeMap(function (line, i) {
            // Shuffle words if shuffle is ordered
            var lineWords = (options.word.type === TeximateOrder.SHUFFLE) ? Helper.shuffle(line.words.slice(0)) : line.words;
            return Observable.of(lineWords)
                .mergeAll()
                .mergeMap(function (wordItem, j) {
                // Process word (calculate index & delay according to word's type)
                // in this case `options.letter.delay` must be 0
                var word = Helper.processWord(options, lineWords, j, 0);
                return Observable.of(word)
                    .delay(word.delay)
                    .do(function () { return _this.updateItem(wordItem, options); });
            });
        });
    };
    TeximateService.prototype.updateItem = function (item, options) {
        /** Display the letter */
        item.visibility = 'visible';
        /** Set animation class */
        item.animateClass = " animated " + options.animation.name;
        /** Update the array */
        this.text.next(this.arr);
    };
    /** Set word/letter hover animation */
    TeximateService.prototype.setItemHover = function (item, options, hover) {
        var _this = this;
        return function () {
            /** hover in effect */
            item.animateClass = " animated " + ((hover.in) ? hover.in : '');
            /** hover out effect */
            setTimeout(function () {
                item.animateClass = " animated " + ((hover.out) ? hover.out : '');
                _this.text.next(_this.arr);
            }, options.animation.duration);
        };
    };
    /** Process and convert text string into a workable text */
    TeximateService.prototype.textFactory = function (text, options, hover) {
        var _this = this;
        var linesArr = [];
        /** get text's lines */
        var lines = text.split('\n');
        lines.map(function (line, i) {
            var wordArr = [];
            /** get line's words and filter empty words */
            var words = line.split(' ');
            words.filter(function (word) { return word !== ''; }).map(function (word, j) {
                var letterArr = [];
                /** get word's letters */
                var letters = word.split(/(?!$)/u);
                letters.map(function (letter, k) {
                    var letterItem = {
                        text: letter,
                        class: ' letter' + (k + 1),
                        animateClass: ' animated ',
                        visibility: (options.type === 'word') ? 'visible' : 'hidden',
                        hover: function () {
                        }
                    };
                    if (hover.type === 'letter') {
                        letterItem.hover = _this.setItemHover(letterItem, options, hover);
                    }
                    letterArr.push(letterItem);
                });
                var wordItem = {
                    letters: letterArr,
                    class: ' word' + (j + 1),
                    animateClass: ' animated ',
                    visibility: 'hidden',
                    hover: function () {
                    }
                };
                if (hover.type === 'word') {
                    wordItem.hover = _this.setItemHover(wordItem, options, hover);
                }
                wordArr.push(wordItem);
            });
            linesArr.push({
                words: wordArr,
                class: ' line' + (i + 1),
                visibility: 'hidden'
            });
        });
        return linesArr;
    };
    return TeximateService;
}());
export { TeximateService };
TeximateService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TeximateService.ctorParameters = function () { return []; };
//# sourceMappingURL=teximate.service.js.map